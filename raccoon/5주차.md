## 캐시 기본 동작

- 캐시가 없는 경우, 서버에서 응답를 받아오고, 똑같은 요청에 대해서도 헤더랑 바디를 만들어서 응답을 만든다.
- 데이터가 변경되지 않더라도 네트워크를 통해 데이터를 다운로드 받아야 하는 문제점이 있다.
- 인터넷 네트워크는 매우 느리고 비싸다.
- 브라우저 로딩 속도가 느려 사용자에게 불편

## 캐시 적용

- cache-control http 헤더에 캐시 유효 시간을 넣어서 전달한다.
- 웹 브라우저 내부에 캐시 저장소가 존재하여 응답 결과를 캐시에 저장한다.
- 두번째 요청부터는 캐시 유효 시간을 검증한 후, 유효한 경우 그대로 사용한다.
- 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.
- 비싼 네트워크 사용량을 줄일 수 있다.
- 브라우저 로딩 속도가 매우 빠르다.
    
    ### 캐시 시간 초과
    
    - 캐시 유효 시간을 초과한 경우에는 다시 요청해야 한다.
    - 서버에선 다시 응답 메시지를 전달하며, 이 메시지를 다시 캐시에 저장한다.
    - 캐시 유효 시간이 초과하면, 서버를 통해 데이터를 다시 조회하고 캐시를 갱신한다.
    - 이 때 다시 네트워크 다운로드가 발생하게 된다.
    - 서버에서 받아오는 데이터랑 캐시 저장소에 있는 데이터가 같더라도 받아와야 할까?

## 검증 헤더와 조건부 요청

- 캐시 유효 시간이 초과한 경우, 서버가 다시 요청하면 두가지 상황 발생
    1. 서버에서 기존 데이터가 변경된 상황
    2. 서버에서 기존 데이터가 변경되지 않은 상황
- 캐시 만료 후, 서버에서 데이터를 변경하지 않았다면 저장해 둔 캐시를 재사용할 수 있다. 단, 클라이언트의 데이터와 서버의 데이터를 비교하는 방법 필요

### 검증 헤더

- Last-Modified http 헤더 추가 → 데이터가 마지막에 수정된 시간
- 캐시 저장소에 데이터의 최종 수정일까지 들어간다.
- 클라이언트가 캐시 유효 시간이 지났다면 다음 요청에 if-modified-since 헤더에 현재 가지고 있는 캐시의 최종 수정일을 넣어서 보낸다. ⇒ 조건부 요청
- 서버는 수정이 되지 않았다면 304 Not Modified와 cache-control, Last-modified 헤더가 포함된 메시지를 넘겨주며, HTTP Body는 따로 전송하지 않는다.
- 클라이언트는 캐시의 데이터를 재사용하며, 캐시 저장소 내의 헤더 데이터만 갱신시킨다.
- 이로 인해 네트워크 부하를 줄일 수 있다.

### 검증 헤더 + 조건부 요청

- 캐시 유효시간이 초과해도 서버의 데이터가 갱신되지 않는다면 304 Not Modified + 헤더 메타 정보만 응답(Body는 X)
- 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보 갱신
- 클라이언트는 캐시에 저장된 데이터 재활용
- 네트워크 다운로드가 발생하기는 하지만, 용량이 적은 헤더 정보만 다운로드
- 매우 실용적인 해결책

### 검증 헤더

- 캐시 데이터와 서버 데이터가 같은지 검증
- Last-Modified, Etag

### 조건부 요청 헤더

- 검증 헤더로 조건에 따른 분기
- If-Modified-Since : Last-Modified 사용
    - If-Modified-Since 이후에 데이터가 수정된다면?
    - 데이터가 변경되지 않았다면 실패. 따라서 304 Not Modified, 헤더 데이터만 전송
    - 데이터가 변경되었다면 성공. 따라서 200 OK, Body를 포함한 모든 데이터 전송
- If-None-Match : ETag 사용
- If-Match, If-Unmodified-Since 태그도 존재한다.
- 조건이 만족하면 200 OK
- 조건이 만족하지 않으면 304 Not Modified

### Last-Modified, If-Modified-Since 단점

- 1초 미만 단위(0.x초)로 캐시 조정 불가능
- 날짜 기반의 로직 사용
- 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우
    - 데이터를 수정하면 수정 날짜가 달라지는데, a→b→a로 수정하는 경우 결론적으론 a가 되어있음. 하지만 날짜는 변경되어 있다.
    - 파일의 날짜는 갱신되어 있지만 파일의 내용은 달라지지 않은 경우, 전체 데이터를 다시 다운로드 하는 문제가 있음.
- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우
    - 스페이스나 주석같은거는 캐시를 유지하고 싶은 경우

### ETag, If-None-Match

- ETag(Entity Tag)
- 캐시용 데이터에 임의의 고유한 버전 이름을 달아둠.
    - 예) ETag: “v1.0”, ETag: “a2jiodwjekjl3”(파일의 Content에 따른 해시, 이 경우 데이터의 내용이 같은 경우 같은 해시값)
- 데이터가 변경되면 이름을 바꾸어서 변경(Hash를 다시 생성)
    - ‘aaaaa’ → ‘bbbbb’
- ETag만 보내서 같으면 유지, 다르면 다시 받기.
- 서버에서는 응답 메세지에 ETag값을 클라이언트에게 전달.
- 클라이언트는 If-None-Match 헤더에 ETag값을 넣어서 서버에 전달한다.
- 두 값이 같으면 데이터가 아직 수정되지 않았다는 의미이므로 304 Not Modified, 캐시 재사용
    
    ### 정리
    
    - ETag만 서버에 보내서 같으면 유지, 다르면 다시 받기
    - 캐시 제어 로직을 서버에서 완전히 관리
    - 클라이언트는 값을 서버에 제공.(캐시 메커니즘을 모름)
        - 베타 오픈 기간인 3일 동안은 파일이 변경되어도 ETag를 동일하게 유지
        - 애플리케이션 배포 주기에 맞추어 ETag를 모두 갱신

## 캐시 제어 헤더

### Cache-Control: 캐시 제어

- Cache-Control: max-age
    - 캐시 유효 시간, 초 단위
- Cache-Control: no-cache
    - 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용
    - 중간 캐시 서버가 아닌, 원 서버에서 검증해야 한다.
    - 캐시를 사용하기 전에 if-modified-since 등으로 항상 서버에 검증해야 한다.
- Cache-Control: no-store
    - 데이터에 민감한 정보가 있으므로 저장하면 안된다.
    - 메모리에서 사용하고 최대한 빠르게 삭제

### Pragma

- Pragma: no-cache
- http 1.0 하위 호환

### Expires

- 캐시 만료일을 정확한 날짜로 지정
- HTTP 1.0부터 사용
- 더 유연한 Cache-Control: max-age 권장
- Cache-Control: max-age와 함께 사용하면 Expires가 무시된다.

## 프록시 캐시

- 미국에 원 서버에 있다고 할 때, 한국에 있는 클라이언트가 미국에 있는 서버에 직접 접근하려면 오랜 시간을 기다려야 한다.
- 해결책으로는 한국 어딘가에 프록시 캐시 서버를 두어 미국 원서버에 요청하는 것이 아닌 프록시 캐시 서버에 요청하도록 한다.
- 프록시 캐시 서버가 원서버에 요청하여 응답을 받은 후 캐시에 저장해 둔다.
- 프록시 캐시서버의 캐시를 public 캐시, 웹 브라우저의 캐시를 private 캐시라고 한다.
- 클라이언트는 빠르게 응답을 받을 수 있다.
- 원서버 → 원래 진짜 자원이 있는 서버

## Cache-Control

- Cache-Control: public
    - 응답이 public 캐시에 저장되어도 됨.
- Cache-Control: private
    - 응답이 해당 사용자만을 위한 것이므로 private 캐시에 저장해야 한다.(기본값)
- Cache-Control: s-maxage
    - 프록시 캐시에만 적용되는 max-age
- Age: 60
    - 오리진 서버(원서버)에서 응답 후 프록시 캐시 내에 머문 시간(초)

## 캐시 무효화

### Cache-Control : 확실한 캐시 무효화 응답

- Cache-Control: no-cache, no-store, must-revalidate
- Pragma: no-cache
    - HTTP 1.0 하위 호환
- 현재 사용자의 통장 잔고는 갱신될 수 있으므로 캐싱되어서는 안된다.
    
    ### Cache-Control
    
    - Cache-Control: no-cache
        - 데이터는 캐시 가능, 항상 원 서버에 검증하고 사용
    - Cache-Control: no-store
        - 데이터에 민감한 정보가 있으므로 저장하면 안됨.
        - 메모리에서 사용하고 최대한 빨리 삭제
    - Cache-Control: must-revalidate
        - 캐시 만료후 최초 조회시 원 서버에 검증
        - 원 서버 접근 실패시 반드시 오류 발생 - 504(Gateway Timeout)
        - must-revalidate는 캐시 유효 시간이라면 캐시 사용
    - Pragma: no-cache
        - HTTP1.0 하위 호환
    

### no-cache vs must-revalidate

### no-cache

- no-cache로 보낸 경우, 원 서버에 접근할 수 없는 경우 캐시 서버 설정에 따라 캐시 데이터를 반환할 수도 있다.
- 원 서버가 순간 네트워크가 단절된 경우 원서버에 접근 불가
- Error을 내거나.. 아니면 200 OK (오류보다는 오래된 데이터라도 보여주자)

### must-revalidate

- 원 서버에 접근할 수 없는 경우 무조건 오류가 발생(504 Gateway Timeout)
- 매우 중요한 돈과 관련된 결과라면?
