# 4주차 HTTP 헤더1

## 목표

스터디를 통해 [모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)을 듣고 요약하며 나누고 싶은 내용을 정리한다.

## HTTP 헤더

HTTP 헤더는 HTTP 전송에 필요한 모든 부가정보를 가지고 있다. 많은 표준 헤더를 가지고 있지만 필요시 임의의 헤더를 추가하여 활용할 수 있다. 이전에 등장한 HTTP 표준인 RFC2616은 폐기 되었으며 2014년 HTTP 표준 RFC7230 ~ 7235가 등장했다. RFC723x에서는 엔티티라고 명시한 것이 `표현(Representation)`으로 변경되었다. 

> ### Representation
> Representation = representation Metadata + Representation Data

## HTTP BODY

보통 `메시지 본문(message body, payload)`을 통해 표현 데이터를 전달한다. 

![](/mat/4주차/images/1.png)

 * `표현`: 요청이나 응답에서 전달한 실제 데이터를 의미한다.
 * `표현 헤더`: 표현 데이터를 해석할 수 있는 정보를 제공한다. 표현 헤더는 세부적으로 표현 메타데이터와 페이로드 메시지로 구분할 수 있다. 

### 표현

 * `Content-Type`: 표현 데이터의 형식을 나타낸다. 예시로는 `text/html;charset=utf-8`, `application/json`등 이 있다.
 * `Content-Encoding`: 표현 데이터의 압축 방식을 나타낸다. 데이터를 전달하는 곳에서 압축한 뒤 인코딩 헤더를 추가한다. 데이터를 받는 클라이언트 쪽은 이러한 인코딩 헤더를 통해 압축 해제를 진행한다. 예시로는 `gzip`, `deflate`, `identity` 등이 있다.
 * `Content-Language`: 표현 데이터의 자연 언어를 나타낸다. 예시로는 `ko`, `en`, `en-US` 등이 있다.
 * `Content-Length`: 표현 데이터의 길이를 나타낸다. 단위는 바이트이다.

이러한 표현 헤더는 전송과 응답에 모두 사용된다.

## 협상 (Content negotiation)

클라이언트가 선호하는 표현 요청을 나타낸다.

 * `Accept`: 클라이언트가 선호하는 미디어 타입을 전달한다.
 * `Accept-Charset`: 클라이언트가 선호하는 문자 인코딩을 나타낸다.
 * `Accept-Encoding`: 클라이언트가 선호하는 압축 인코딩을 나타낸다.
 * `Accept-Language`: 클라이언트가 선호하는 언어를 나타낸다.

이러한 협상 헤더는 요청 시 활용된다. 하지만 서버에서 제공하지 않는 경우 말짱 도루묵이 된다. 그래도 클라이언트는 최대한 원하는 것의 우선순위를 잘 정리하여 요청해야 한다.

## 전송 방식

### 단순 전송

단순한 전송할 경우 `Content-Length`에 표현 데이터의 바이트 만큼 명시하여 전달한다.

### 압축 전송

`Content-Encoding`을 활용한다. 해당 정보가 존재해야 클라이언트가 적절히 압축을 해제하고 활용할 수 있다.

### 분할 전송

`Trasfer-Encoding` 헤더를 활용한다. 

![](/mat/4주차/images/2.png)

브라우저에서 해당 헤더를 확인한 뒤 `chuncked`된 데이터를 알아서 처리해준다. 이때 `Content-Length`를 명시하면 안된다. 총 길이를 예상할 수 없기 때문이다.

### 범위 전송

요청 시 `Range` 헤더에 범위를 담아 전달하고 응답에 `Content-Range` 헤더에 담아 반환한다.

## 일반 정보

### From

유저 에이전트의 이메일 정보를 나타낸다. 일반적으로 잘 사용되지 않지만 검색 엔진에서 사용된다고 한다.

### Referer

이전 웹 페이지의 주소를 나타낸다. 이러한 헤더를 통해 유입 경로를 분석할 수 있다. 요청에서만 사용되며 개인 정보의 보호를 위해 도메인을 제외한 추가정보는 지워진 채 명시된다. 주로 요청에서 사용된다.

### User-Agent

유저 에이전트의 애플리케이션 정보를 가지고 있다. 이러한 헤더의 정보를 모으면 유의미한 통계로 활용할 수 있다. 가령 어떤 종류의 기기나 브라우저에서 장애가 발생하는지 쉽게 파악할 수 있다. 이 또한 요청에서만 사용된다. 

### Server

요청을 처리하는 서버의 소프트웨어 정보를 나타낸다. 주로 응답에서 사용한다.

### Date

해당 메시지가 발생한 날짜와 시간을 나타낸다. 응답에서 사용된다.

## 특별한 정보

### Host

요청한 호스트의 정보를 나타내며 필수로 있어야 한다. 하나의 서버, 즉 하나의 IP 주소에 여러 도메인이 적용되어 있을 때 해당 호스트 정보를 통해 접근한다. 가상 호스트를 사용하면 한 IP에서 여러 도메인 처리가 가능하다. 이때 호스트 정보는 필수적이다.

### Location

웹 브라우저에서 3xx의 상태 코드를 가진 응답에 Location 헤더가 있으면 해당 위치로 리다이렉트한다. 이 뿐만 아니라 `201`을 통한 리소스 생성에도 생성된 리소스의 URI를 명시할 때도 활용된다.

### Allow

메서드를 허용하지 않는 상태 코드인 `405 Method Not Allowed`을 활용할 때 응답에 포함해야 한다. 

## 인증

### Authorization

클라이언트의 인증 정보를 서버에 전달한다. 

### WWW-Authenticate

특정 리소스를 접근할 때 필요한 인증 방법을 정의한다. 보통 `401 Unauthorized` 응답과 함께 사용된다. 즉 해당 정보를 참고해서 인증 정보를 만들라는 의미를 내포하고 있다.

## 쿠키

 * `Set-Cookie`: 서버에서 클라이언트로 쿠기를 전달한다.
 * `Cookie`: 클라이언트가 서버에서 받은 쿠키를 저장하고 HTTP 요청 시 서버로 전달한다.

이러한 쿠키 사용은 무상태 프로토콜인 HTTP에서 상태를 필요로할 때 (로그인 등) 활용된다.

![](/mat/4주차/images/3.png)

저장된 쿠키는 모든 요청에 `Cookie` 헤더를 통해 자동으로 포함되어 전달된다. 브라우저는 보통 각 사이트에 생성한 쿠키를 URL와 매핑하여 관리한다. 해당 URL 사이트에 접속할 때 매핑된 쿠키가 있으면 요청에 무조건 포함해서 보내야 한다. 이러한 쿠키 정보를 기반으로 로그인 유무를 확인할 수 있다.

보통 쿠키는 사용자 로그인 세션을 관리할 때 주로 사용된다. 쿠키 정보는 앞서 언급한 것 처럼 항상 서버에 전송되기 때문에 최소한의 정보를 가지고 있어야 한다. 주의해야 할 점은 보안에 민감한 데이터는 저장하면 안된다!

### 쿠키 - 생명 주기

쿠키의 생명주기는 서버에서 응답을 보낼 때 `Set-Cookie`에서 `expires`와 `max-age`를 통해 설정 가능하다. 

 * `expires`: 만료일을 명시하며 해당 일이 되면 쿠키를 삭제한다.
 * `max-age`: 초 단위로 지정한다. 0이나 음수를 지정하면 쿠키를 삭제한다.
 * `세션 쿠키`: 만료 날짜를 생략하면 브라우저 종료 까지만 유지된다.
 * `영속 쿠키`: 만료 날짜를 입력하면 해당 날짜까지 유지된다.

### 쿠키 - 도메인

쿠키에 domain 설정을 명시하면 명시한 기준 도메인과 서브 도메인을 포함하여 함께 전송한다. 생략할 경우 현재 문서 기준 도메인에만 적용되어 전달한다.

### 쿠키 - 경로

쿠키에 path 설정을 명시하면 해당 경로를 포함한 하위 경로 페이지만 쿠키에 접근 가능하다. 보통은 `/`로 지정한다.

### 쿠키 - 보안

 * `Secure`: 쿠키는 보통 `http`, `https`를 구분하지 않고 전송한다. 해당 설명을 명시하면 `https`인 경우에만 전송한다. 
 * `HttpOnly`: 자바스크립트에서 쿠키 접근을 막아 `XSS` 공격을 방지한다. HTTP 전송에만 사용된다.
 * `SameSite`: `XSRF` 공격 방지를 위해 사용한다. 요청 도메인과 쿠키에 설정된 도메인이 같은 경우에만 쿠키를 전송한다.

## 공유하고 싶은 내용

## 요청한 호스트 정보(도메인)

가상 호스트를 사용하면 한 IP에서 여러 도메인 처리가 가능하다고 한다. 이전에 언급된 Port는 어떤식으로 개념이 분리되는 것인가?

## Spring 에서 쿠키 세션을 활용하는 방법

[6. 로그인 처리 1 - 쿠키, 세션](https://catsbi.oopy.io/0c27061c-204c-4fbf-acfd-418bdc855fd8)

## References

[모든 개발자를 위한 HTTP 웹 기본 지식](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)
[6. 로그인 처리 1 - 쿠키, 세션](https://catsbi.oopy.io/0c27061c-204c-4fbf-acfd-418bdc855fd8)
